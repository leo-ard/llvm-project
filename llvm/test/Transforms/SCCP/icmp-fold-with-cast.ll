; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --tool ./bin/opt --version 3
; See PRXXX for more details
; RUN: opt < %s -S -passes=ipsccp | FileCheck %s


define signext i32 @sext_sext(i16 %x, i16 %y) {
; CHECK-LABEL: define signext i32 @sext_sext(
; CHECK-SAME: i16 [[X:%.*]], i16 [[Y:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CONV:%.*]] = sext i16 [[X]] to i32
; CHECK-NEXT:    [[CONV1:%.*]] = sext i16 [[Y]] to i32
; CHECK-NEXT:    [[CMP2:%.*]] = icmp sgt i16 [[X]], [[Y]]
; CHECK-NEXT:    br i1 [[CMP2]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]]
; CHECK:       cond.true:
; CHECK-NEXT:    br label [[COND_END:%.*]]
; CHECK:       cond.false:
; CHECK-NEXT:    br label [[COND_END]]
; CHECK:       cond.end:
; CHECK-NEXT:    [[COND:%.*]] = phi i32 [ 0, [[COND_TRUE]] ], [ 1, [[COND_FALSE]] ]
; CHECK-NEXT:    ret i32 [[COND]]
;
entry:
  %conv = sext i16 %x to i32
  %conv1 = sext i16 %y to i32
  %cmp2 = icmp sgt i32 %conv, %conv1
  br i1 %cmp2, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  br label %cond.end

cond.false:                                       ; preds = %for.body
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 0, %cond.true ], [ 1, %cond.false ]
  ret i32 %cond
}


define signext i32 @zext_zext(i16 %x, i16 %y) {
; CHECK-LABEL: define signext i32 @zext_zext(
; CHECK-SAME: i16 [[X:%.*]], i16 [[Y:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CONV:%.*]] = zext i16 [[X]] to i32
; CHECK-NEXT:    [[CONV1:%.*]] = zext i16 [[Y]] to i32
; CHECK-NEXT:    [[CMP2:%.*]] = icmp sgt i16 [[X]], [[Y]]
; CHECK-NEXT:    br i1 [[CMP2]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]]
; CHECK:       cond.true:
; CHECK-NEXT:    br label [[COND_END:%.*]]
; CHECK:       cond.false:
; CHECK-NEXT:    br label [[COND_END]]
; CHECK:       cond.end:
; CHECK-NEXT:    [[COND:%.*]] = phi i32 [ 0, [[COND_TRUE]] ], [ 1, [[COND_FALSE]] ]
; CHECK-NEXT:    ret i32 [[COND]]
;
entry:
  %conv = zext i16 %x to i32
  %conv1 = zext i16 %y to i32
  %cmp2 = icmp sgt i32 %conv, %conv1
  br i1 %cmp2, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  br label %cond.end

cond.false:                                       ; preds = %for.body
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 0, %cond.true ], [ 1, %cond.false ]
  ret i32 %cond
}


define signext i16 @zext_positive_and_sext(i32 noundef %n, ptr noundef %v) {
; CHECK-LABEL: define signext i16 @zext_positive_and_sext(
; CHECK-SAME: i32 noundef [[N:%.*]], ptr noundef [[V:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[P_0:%.*]] = phi i16 [ 0, [[ENTRY:%.*]] ], [ [[CONV8:%.*]], [[COND_END:%.*]] ]
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ 0, [[ENTRY]] ], [ [[INC:%.*]], [[COND_END]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[I_0]], [[N]]
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[CONV:%.*]] = zext i16 [[P_0]] to i32
; CHECK-NEXT:    [[IDXPROM:%.*]] = sext i32 [[I_0]] to i64
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr i16, ptr [[V]], i64 [[IDXPROM]]
; CHECK-NEXT:    [[TMP0:%.*]] = load i16, ptr [[ARRAYIDX]], align 2
; CHECK-NEXT:    [[CONV1:%.*]] = sext i16 [[TMP0]] to i32
; CHECK-NEXT:    [[CMP2:%.*]] = icmp slt i16 [[P_0]], [[TMP0]]
; CHECK-NEXT:    br i1 [[CMP2]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]]
; CHECK:       cond.true:
; CHECK-NEXT:    br label [[COND_END]]
; CHECK:       cond.false:
; CHECK-NEXT:    br label [[COND_END]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret i16 [[P_0]]
; CHECK:       cond.end:
; CHECK-NEXT:    [[COND:%.*]] = phi i32 [ [[CONV1]], [[COND_TRUE]] ], [ [[CONV]], [[COND_FALSE]] ]
; CHECK-NEXT:    [[CONV8]] = trunc i32 [[COND]] to i16
; CHECK-NEXT:    [[INC]] = add nsw i32 [[I_0]], 1
; CHECK-NEXT:    br label [[FOR_COND]]
;
entry:
  br label %for.cond

for.cond:                                         ; preds = %cond.end, %entry
  %p.0 = phi i16 [ 0, %entry ], [ %conv8, %cond.end ]
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %cond.end ]
  %cmp = icmp slt i32 %i.0, %n
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.body:                                         ; preds = %for.cond
  %conv = zext i16 %p.0 to i32                    ;; %p.0 is always positive here
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr i16, ptr %v, i64 %idxprom
  %0 = load i16, ptr %arrayidx, align 2
  %conv1 = sext i16 %0 to i32
  %cmp2 = icmp slt i32 %conv, %conv1
  br i1 %cmp2, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  br label %cond.end

cond.false:                                       ; preds = %for.body
  br label %cond.end

for.cond.cleanup:                                 ; preds = %for.cond
  ret i16 %p.0

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv1, %cond.true ], [ %conv, %cond.false ]
  %conv8 = trunc i32 %cond to i16
  %inc = add nsw i32 %i.0, 1
  br label %for.cond
}



define signext i16 @sext_and_zext_positive(i16 %x) {
; CHECK-LABEL: define signext i16 @sext_and_zext_positive(
; CHECK-SAME: i16 [[X:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[V:%.*]] = phi i16 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[COND_END:%.*]] ]
; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[CONV:%.*]] = zext i16 [[V]] to i32
; CHECK-NEXT:    [[CONV1:%.*]] = sext i16 [[X]] to i32
; CHECK-NEXT:    [[CMP2:%.*]] = icmp slt i16 [[X]], [[V]]
; CHECK-NEXT:    br i1 [[CMP2]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]]
; CHECK:       cond.true:
; CHECK-NEXT:    br label [[COND_END]]
; CHECK:       cond.false:
; CHECK-NEXT:    br label [[COND_END]]
; CHECK:       cond.end:
; CHECK-NEXT:    [[A:%.*]] = phi i16 [ 10, [[COND_TRUE]] ], [ 20, [[COND_FALSE]] ]
; CHECK-NEXT:    [[INC]] = add nuw nsw i16 [[A]], 1
; CHECK-NEXT:    br label [[FOR_COND]]
;
entry:
  br label %for.cond

for.cond:                                         ; preds = %cond.end, %entry
  %v = phi i16 [ 0, %entry ], [ %inc, %cond.end ] ;; always positive
  br label %for.body

for.body:                                         ; preds = %for.cond
  %conv = zext i16 %v to i32                    ;; %p.0 is always positive here
  %conv1 = sext i16 %x to i32                    ;; %p.0 is always positive here
  %cmp2 = icmp slt i32 %conv1, %conv ;; positive/positive
  br i1 %cmp2, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  br label %cond.end

cond.false:                                       ; preds = %for.body
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %a = phi i16 [ 10, %cond.true ],  [ 20, %cond.false ]
  %inc = add i16 %a, 1
  br label %for.cond
}
